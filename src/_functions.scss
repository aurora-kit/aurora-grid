// Aurora Grid :: Functions


/// %clearfix :: placeholder 
%clearfix {
  &:before,
  &:after {
    content: " ";
    display: table;
  }
  &:after {
    clear: both;
  }
}


/// em :: @function to transform px (an unitless) to em 
/// @param {Number}  $px                      - Value to calculate in ems
/// @param {Number}  $fz [$ae-font-size)]     - Base font size to make calculations
@function em($px, $fz: $ae-font-size) {
    @if unitless($px) {
        @warn "#{$px} must be in pixels. Transformed to #{$px}px.";
        @return em($px * 1px, $fz);
    } @else if unit($px) == em {
        @return $px;
    }
    @return ($px / $fz) * 1em;
}


/// ae-visual-debug :: @mixin to set debuggin styles to an element
/// @param {Color}    $col             - Color to apply on borders and background (on hover)
/// @param {Number}   $offset          - Value to offset the outline if necessary
/// @param {Boolean}  $hover [false]   - Enable the hover behavior
/// @param {Number}   $nested [1]      - Quantity of nested elements to apply darken color, 1 no nested.
@mixin ae-visual-debug($col, $offset, $hover: false, $nested: 1) {
  outline: 1px solid $col !important;
  outline-offset: if($offset, $offset, 0);

  @if $hover {
    &:hover {
      background-color: $col !important;
    }

    $nest: null;
    @for $i from 1 to $nested {
      $nest: $nest #{&};

      #{$nest}:hover {
       background-color: darken($col, 10*$i) !important; 
      }
    }
    
  }
}


/// ae-text-debug :: @mixin to set text on body for debugging purposes
/// @param {String} $text             - Text to show on the upper right corner of the page
/// @param {Color}  $color            - Text color 
/// @param {Color}  $bg               - Background color
@mixin ae-text-debug($text, $color, $bg) {
  body:after {
    background-color: rgba($bg, .7);
    color: $color;
    font: 16px/1.5 sans-serif;
    padding: 5px 8px;
    pointer-events: none;
    position: fixed;
    right: 0;
    top: 0;
    z-index: 900;
    content: '#{$text}';
  }
}

/// ae-breakpoints :: @mixin to set breakpoints
/// @param {String | Number}  $min [null]             - Value to set `min-width` query or key map that represents it
/// @param {String | Number}  $max [null]             - Value to set `max-width` query or key map that represents it
/// @param {String}           $type [all]             - Media type like `screen` or `print`
/// @param {Map}              $bps [$ae-breakpoints]  - Map to find $min or $max params if necessary
@mixin ae-breakpoints($min:null, $max: null, $type: all, $bps: $ae-breakpoints) {
  
  // Min
  @if type-of($min) == number {
    $min-val: if($min != 0, em($min), 0);
  } @else {
    $min-val: if(map-has-key($bps, $min), if(map-get($bps, $min) != 0, em(map-get($bps, $min)), 0), null);
  }

  // Max
  @if type-of($max) == number {
      $max-val: em($max);
  } @else {
      $max-val: if(map-has-key($bps, $max), em(map-get($bps, $max) - .01em), null);
  }

  // Output
  $query: null;
  $min-query: if($min-val and $min-val != 0, '(min-width: #{$min-val})', null);
  $max-query: if($max-val, '(max-width: #{$max-val})', null);
  $type-query: if($type == all and ($min-val or $max-val), null, $type );
  $queries: (
    type: $type-query,
    min: $min-query,
    max: $max-query
  );
  
  @each $prop, $value in $queries {
    @if map-get($queries, $prop) {
      @if not $query {
        $query: #{$value};
      } @else {
        $query: #{$query} and #{$value};
      }
    }
  }
  
  @if $min-val and not $min-query and not $max-query {
    @content;
  } @else {
    @media #{$query} {
      @content;
    }
  }

}


/// ae-item-space :: @mixin to set the space for an item
/// @param {Number}  $col                     - The quantity of columns to fill
/// @param {Number}  $cols [$ae-columns]      - Total columns of the grid
@mixin ae-item-space($col, $cols: $ae-columns) {
  flex: 0 0 percentage($col / $cols);
  @if $ae-grid-float {
    width: percentage($col / $cols);
  }
}


/// ae-item-offset :: @mixin to set the offset for an item
/// @param {Number}  $col                     - The quantity of columns to move
/// @param {Number}  $cols [$ae-columns]      - Total columns of the grid
@mixin ae-item-offset($col, $cols: $ae-columns) {
  margin-left: percentage($col / $cols);
}


/// ae-item-push :: @mixin to push right an item
/// @param {Number}  $col                     - The quantity of columns to move
/// @param {Number}  $cols [$ae-columns]      - Total columns of the grid
@mixin ae-item-push($col, $cols: $ae-columns) {
  left: if($col > 0, percentage($col / $cols), auto);
}


/// ae-item-push :: @mixin to pull left an item
/// @param {Number}  $col                     - The quantity of columns to move
/// @param {Number}  $cols [$ae-columns]      - Total columns of the grid
@mixin ae-item-pull($col, $cols: $ae-columns) {
  right: if($col > 0, percentage($col / $cols), auto);
}


/// ae-container :: @mixin to set the styles for a Container element
/// @param {Number}  $gut [$ae-gutter]                                 - The gutter to apply on both sides
/// @param {Number | Map}  $max-whidth [$ae-container-max-width]       - The max width, static or responsive (in case the value is a Map)
@mixin ae-container($gut: $ae-gutter, $max-width: $ae-container-max-width) {
  @extend %clearfix;
  margin-right: auto;
  margin-left: auto;
  padding-left: ($gut / 2);
  padding-right: ($gut / 2);
  
  $units: em, ex, ch, rem, vh, vw, vmin, vmax, px, mm, cm, in, pt, pc, '%';

  @if type-of($max-width) == number {
    @if not unitless($max-width) and index($units, unit($max-width)) {
      max-width: $max-width;  
    }
  } @else if type-of($max-width) == map {
    @each $bp, $size in $max-width {
      @include ae-breakpoints($bp) {
        max-width: $size;
      }
    }
  }
}

/// ae-grid :: @mixin to set the styles for a Grid element
/// @param {Number}  $gut [$ae-gutter]        - The gutter to balance on both sides
@mixin ae-grid($gut: $ae-gutter) {
  @if $ae-grid-float { @extend %clearfix; }
  display: flex;
  flex-wrap: wrap;
  margin-left: ($gut / -2);
  margin-right: ($gut / -2);
}

/// ae-grid-item :: @mixin to set the styles for a Grid Item element
/// @param {Number}  $gut [$ae-gutter]        - The gutter to apply on both sides
@mixin ae-grid-item($gut: $ae-gutter) {
  min-height: 1px;
  padding-left: $gut / 2;
  padding-right: $gut / 2;
  position: relative;
  @if $ae-grid-float { float: left; }
}

/// ae-grid :: @mixin to set the styles for a Grid element
/// @param {Number}  $cols [$ae-columns]             - The total of columns
/// @param {Number}  $gut [$ae-gutter]               - The gutter to apply on both sides of each item
/// @param {Map}     $bps [$ae-breakpoints]          - The breakpoints on which loop and set the media queries
@mixin ae-grid-items($cols: $ae-columns, $gut: $ae-gutter, $bps: $ae-breakpoints) {
  
  .#{$ae}-grid__item {
    min-height: 1px;
    padding-left: $gut / 2;
    padding-right: $gut / 2;
    position: relative;    
  }

  @each $bp in map-keys($bps) {
    @include ae-breakpoints($bp) {
      .item-#{$bp}--auto {
        flex: 1;
      }

      @for $i from 1 through $cols {
        .item-#{$bp}-#{$i} {
          @if $ae-grid-float { float: left; }
          @include ae-item-space($i, $cols);
        }
      }
      @each $move in (pull, push, offset) {
        @for $i from 1 through $cols {
          .item-#{$bp}--#{$move}-#{$i} {
            @if $move == push {
              @include ae-item-push($i, $cols);
            } @else if $move == pull {
              @include ae-item-pull($i, $cols);
            } @else if $move == offset {
              @include ae-item-offset($i, $cols);
            }
          }
        }
      }
      
      @if $ae-flex-align {
        .item-#{$bp}--start { order: -1; }
        .item-#{$bp}--end { order: 10; }
        .item-#{$bp}--top { align-self: flex-start; }
        .item-#{$bp}--center { align-self: center; }
        .item-#{$bp}--bottom { align-self: flex-end; }

        .items-#{$bp}--top { align-items: flex-start; }
        .items-#{$bp}--center { align-items: center; }
        .items-#{$bp}--bottom { align-items: flex-end; }
      }

      @if $ae-flex-order {
        @for $i from 1 through $cols {
          .item-#{$bp}--order-#{$i} {
            order: $i;
          }
        }
      }

    }
  }

}
